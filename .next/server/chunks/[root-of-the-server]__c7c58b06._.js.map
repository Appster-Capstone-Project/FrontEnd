{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/api/events/stream/route.ts"],"sourcesContent":["// src/app/api/events/stream/route.ts\nimport {NextRequest} from 'next/server';\nimport {PassThrough} from 'stream';\n\n// This is the backend endpoint we will be proxying to.\nconst BACKEND_SSE_URL = `${process.env.NEXT_PUBLIC_API_BASE_URL}/events/stream`;\n\nexport const dynamic = 'force-dynamic'; // Ensures this route is not statically built\n\nexport async function GET(req: NextRequest) {\n  const authToken = req.headers.get('Authorization');\n\n  if (!authToken) {\n    return new Response('Authorization header is required', {status: 401});\n  }\n\n  // Create a transform stream that will be piped to the client.\n  const stream = new PassThrough();\n\n  try {\n    const response = await fetch(BACKEND_SSE_URL, {\n      method: 'GET',\n      headers: {\n        Authorization: authToken,\n        'Content-Type': 'text/event-stream',\n        Connection: 'keep-alive',\n        'Cache-Control': 'no-cache',\n      },\n    });\n\n    if (!response.ok || !response.body) {\n      const text = await response.text();\n      console.error(\n        `[SSE PROXY] Backend connection failed: ${response.status} ${response.statusText}`,\n        text\n      );\n      return new Response(\n        `Failed to connect to the backend event stream: ${text}`,\n        {status: response.status}\n      );\n    }\n\n    const reader = response.body.getReader();\n\n    const push = async () => {\n      while (true) {\n        const {done, value} = await reader.read();\n        if (done) {\n          stream.end();\n          break;\n        }\n        stream.write(value);\n      }\n    };\n\n    push().catch(e => {\n      console.error('[SSE PROXY] Error while reading from backend:', e);\n      stream.end();\n    });\n\n    // Return the stream to the client.\n    return new Response(stream as any, {\n      headers: {\n        'Content-Type': 'text/event-stream',\n        'Cache-Control': 'no-cache',\n        Connection: 'keep-alive',\n      },\n    });\n  } catch (error) {\n    console.error('[SSE PROXY] Fetching backend stream failed:', error);\n    return new Response('Internal Server Error while connecting to stream', {\n      status: 500,\n    });\n  }\n}\n"],"names":[],"mappings":"AAAA,qCAAqC;;;;;AAErC;;AAEA,uDAAuD;AACvD,MAAM,kBAAkB,kEAAwC,cAAc,CAAC;AAExE,MAAM,UAAU,iBAAiB,6CAA6C;AAE9E,eAAe,IAAI,GAAgB;IACxC,MAAM,YAAY,IAAI,OAAO,CAAC,GAAG,CAAC;IAElC,IAAI,CAAC,WAAW;QACd,OAAO,IAAI,SAAS,oCAAoC;YAAC,QAAQ;QAAG;IACtE;IAEA,8DAA8D;IAC9D,MAAM,SAAS,IAAI,qGAAA,CAAA,cAAW;IAE9B,IAAI;QACF,MAAM,WAAW,MAAM,MAAM,iBAAiB;YAC5C,QAAQ;YACR,SAAS;gBACP,eAAe;gBACf,gBAAgB;gBAChB,YAAY;gBACZ,iBAAiB;YACnB;QACF;QAEA,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,SAAS,IAAI,EAAE;YAClC,MAAM,OAAO,MAAM,SAAS,IAAI;YAChC,QAAQ,KAAK,CACX,CAAC,uCAAuC,EAAE,SAAS,MAAM,CAAC,CAAC,EAAE,SAAS,UAAU,EAAE,EAClF;YAEF,OAAO,IAAI,SACT,CAAC,+CAA+C,EAAE,MAAM,EACxD;gBAAC,QAAQ,SAAS,MAAM;YAAA;QAE5B;QAEA,MAAM,SAAS,SAAS,IAAI,CAAC,SAAS;QAEtC,MAAM,OAAO;YACX,MAAO,KAAM;gBACX,MAAM,EAAC,IAAI,EAAE,KAAK,EAAC,GAAG,MAAM,OAAO,IAAI;gBACvC,IAAI,MAAM;oBACR,OAAO,GAAG;oBACV;gBACF;gBACA,OAAO,KAAK,CAAC;YACf;QACF;QAEA,OAAO,KAAK,CAAC,CAAA;YACX,QAAQ,KAAK,CAAC,iDAAiD;YAC/D,OAAO,GAAG;QACZ;QAEA,mCAAmC;QACnC,OAAO,IAAI,SAAS,QAAe;YACjC,SAAS;gBACP,gBAAgB;gBAChB,iBAAiB;gBACjB,YAAY;YACd;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+CAA+C;QAC7D,OAAO,IAAI,SAAS,oDAAoD;YACtE,QAAQ;QACV;IACF;AACF","debugId":null}}]
}